\chapter{Implementierung von Rayden}
\label{cha:Implementierung}

Diese Kapitel beschreibt die Implementierung von ausgewählten Komponenten des Rayden-System. Die Abschnitte \ref{cha:KeywordGrammar} und \ref{cha:StackMachine} zeigen die Grammatik und die \enword{Stack}-Maschine für die Ausführung von \enword{Keywords}. Die Abschnitte enthalten Codeauschnitte der Implementierung und Teile der xText-Grammtik.

\SuperPar
Der Abschnitt \ref{cha:Eval} befasst sich mit der Umsetzung von Ausdrücken im Rayden-System. Dazu werden in diesem Abschnitt Auszüge der Grammatik und Teile der \enword{RaydenExpressionEvaluator} Klasse erklärt. Die Klasse \enword{RaydenExpressionEvaluator} ist für die Auswertung der Ausdrücke zuständig. 

\SuperPar
Im Abschnitt \ref{cha:validateKeyword} wird die Validierung von Rayden-Tests gezeigt. Dafür wird das Validierungssystem von \enword{xText} verwendet. Abgeschlossen wird diese Kapitel mit dem Abschnitt \ref{cha:implementJSA}, welcher die Integration des Rayden-Systems in das \enword{Java-Scripting-API} zeigt. 

%%------------------------------------------------------------------------------------------------------

\section{Umsetzung der \enword{Keyword}-Grammatik}
\label{cha:KeywordGrammar}

Die Rayden-Sprache wurde mit dem xText \cite{xtext} Compilerwerkzeug umgesetzt. Die Abbildung \ref{fig:keywordGrammar} zeigt einen Auszug aus der Grammatik für die Rayden-Sprache. Der Auszug zeigt die Grammatikregeln für \enword{Keywords}. Die Regel \enword{KeywordDecl} beginnt die Definition eines neuen \enword{Keywords}. Am Beginn der Regel wird der Typ für das \enword{Keyword} definiert. Eine Beschreibung und Auflistung der Typen ist in Abschnitt \ref{cha:KeywordTypes} enthalten. Danach folgt ein Name für das \enword{Keyword} welcher von einer öffneten geschwungenen Klammer gefolgt wird.

\begin{figure}
\centering
\includegraphics[width=0.9\textwidth]{grammar-keyword-all.png}
\caption{Auszug aus der Grammatik für \enword{Keywords}}
\label{fig:keywordGrammar}
\end{figure}

\SuperPar
Die geschwungenen Klammer definieren den Bereich der \enword{Keyword}-Implementierung. Am Anfang der Implementierung kann eine optionale Beschreibung angeführt werden. Diese wird von einer Parameterliste gefolgt. Ein Parameter wird mit der Regel \enword{ParameterDecl} beschrieben und kann 0 bis N Mal wiederholt werden. Eine Parameter-Definition besteht aus dem Schlüsselwort \enword{parameter}, einen Namen, einen Datentyp und einer Richtung.

\SuperPar
Danach folgt entweder die Bindung an ein Codestück mit der Regel \enword{KeywordScript} oder die \enword{Keyword}-Liste mit der Regel \enword{KeywordList} im Fall eines \enword{Compound-Keywords}. Die beiden Regeln sind wiederum optional um \enword{Keyword}-Rümpfe anlegen zu können. Diese Eigenschaft ist hilfreich, wenn die Testmanagerin oder der Testmanager nur die Struktur festlegen möchte, die Umsetzung des \enword{Keywords} jedoch von einem anderen Testpersonal vorgenommen wird. 

\begin{program}
\begin{JavaCode}
  Type Text (@PetClinic.PetClinicWeb.Login.Username , "max.mustermann")
	@PetClinic.PetClinicWeb.Login.Username :: Type Text ("max.mustermann")
	
	
	Click Left( @PetClinic.PetClinicWeb.Login.Go )
  @PetClinic.PetClinicWeb.Login.Go :: Click Left
\end{JavaCode}
\caption{Syntaktischer Zucker für die Verwendung von \enword{location}-Datentypen}
\label{prog:locatorSugar}
\end{program}

\SuperPar
Die Regel \enword{KeywordCall} definiert den Aufruf von einem \enword{Keyword} in einer \enword{Keyword}-Liste. Die Regel fängt normalerweise mit dem Namen des aufzurufenden \enword{Keywords} an. Danach folgt optional die Parameterliste für den Aufruf von dem \enword{Keyword}. Die Regel \enword{KeywrodCallParameter} definiert die Parameterliste, welche durch runde Klammer umschlossen ist. Die Parameter können als Liste von \enword{Expr}-Regeln definiert werden und werden durch einen Beistrich separiert werden. Für die einfachere Verwendung und besserer Lesbarkeit enthält die Regel \enword{KeywordCall} auch noch syntaktischen Zucker. Falls der erste Parameter von einem \enword{Keyword} vom Typen \enword{location} ist, kann diese Parameter vor das \enword{Keyword} geschrieben werden. Somit lässt sich die Implementierung leicht lesen. Der Codeausschnitt in Abbildung \ref{prog:locatorSugar} zeigt dazu die Verwendung des syntaktischen Zuckers im Vergleich zur klassischen Verwendung. Am Ende der \enword{KeywordCall}-Regel ist es noch möglich eine \enword{Keyword}-Liste zu definieren. Diese wird benötigt, falls es sich um ein \enword{Scripted-Compound-Keyword} oder um ein \enword{Inline-Keyword} handelt.

%%------------------------------------------------------------------------------------------------------

\section{Ausführung von \enword{Keywords} mit einer \enword{Stack}-Maschine}
\label{cha:StackMachine}

Im vorigen Abschnitt \ref{cha:KeywordGrammar} wurde die Grammatik von einem \enword{Keyword} in der Sprache Rayden erklärt. Dieser Abschnitt beschäftigt sich mit der Ausführung von \enword{Keywords}. Damit die \enword{Stack}-Maschine arbeiten kann, benötigt diese einen Zugriff auf den abstrakten Syntaxbaum. 

\begin{figure}
\centering
\includegraphics[width=1\textwidth]{keyword-model-diagramm.png}
\caption{Ausschnitt aus dem Abstrakte Syntaxbaum}
\label{fig:AST}
\end{figure}

\SuperPar
Das Compilerwerkzeug \enword{xText} stellt dafür ein \enword{Eclispe-ECore}-Modell zur Verfügung. Der generierten Compiler ist so konzipiert, dass dieser die gesamte Datei einliest und daraus einen abstrakten Syntaxbaum generiert. Der Syntaxbaum steht für die weitere Verarbeitung als \enword{ECore}-Modell zur Verfügung. Einen Auszug aus dem Modell zeigt die Abbildung \ref{fig:AST}. Die Abbildung zeigt die Modell-Repräsentation der Grammatik-Regeln von Abbildung \ref{fig:keywordGrammar}. Dieser Ausschnitt aus dem Modell stellt die Basis für die \enword{Stack}-Maschine dar. 

\SuperPar
Die \enword{Stack}-Maschine für das Rayden-System ist in der Klasse \enword{RaydenRuntime} implementiert. Der Codeauszug \ref{prog:runtime} zeigt die essentielle Methode \enword{executeKeyword}, welche für die Ausführung verantwortlich ist. Die Methode wird mit einem \enword{KeywordCall}-Objekt aufgerufen. Diese Objekt bezeichnet das erste \enword{Keyword}, welches von der \enword{Stack}-Maschine aufgerufen wird. Als erstes wird in der Methode übriggebliebene Element von dem \enword{Stack} entfernt. Danach wird über das \enword{Reporter-Interface} alle Objekte notifiziert, dass ein neuer Testfall gestartet worden ist. Im nächsten Schritt wird ein neuer Gültigkeitsbereich (\enword{RaydenScriptScope}) angelegt und mit dem \enword{KeywordCall}-Objekt initialisiert. Der Gültigkeitsbereich wird dann auf den leeren \enword{Stack} geladen. 

\SuperPar
Nach der Initialisierung der \enword{Stack}-Maschine wird die Abarbeitung gestartet. Es werden nun solange die Gültigkeitsbereiche am \enword{Stack} abgearbeitet, bis der \enword{Stack} leer ist oder ein Fehler bei der Ausführung von einem \enword{Keyword} aufgetreten ist. Der Gültigkeitsbereich repräsentiert einen Aufruf von einem \enword{Keyword} und die dazugehörigen Parameter und Variablen. Der Gültigkeitsbereich speichert zusätzlich die aktuelle Position in der \enword{Keyword}-Liste, falls es sich um ein \enword{Compound-Keyword} oder \enword{Scripted-Compound-Keyword} handelt. Über die Methode \enword{getNextOpt} kann die \enword{Stack}-Maschine das nächste \enword{Keyword} aus dem aktuellen Gültigkeitsbereich laden. Liefert die Methode kein Wert, ist die Ausführung des Gültigkeitsbereiches am Ende und wird daher vom \enword{Stack} entfernt.

\begin{program}
\lstinputlisting{samplecode/Runtime.java}
\caption{Codeauszug aus der \enword{RaydenRuntime}-Klasse}
\label{prog:runtime}
\end{program}

\SuperPar
Wurde jedoch ein Wert zurückgeliefert, wird mit der Ausführung fortgefahren. Handelt es sich bei dem Wert um ein \enword{KeywordCall}-Objekt, wird die Methode \enword{executeKeywordCall} aufgerufen. Diese Methode löst den Aufruf des \enword{Keywords} über eine \enword{Lookup}-Tabelle auf. Wurde die passende \enword{Keyword}-Implementierung gefunden, wird ein neuer Gültigkeitsbereich angelegt und auf den \enword{Stack} geladen. Wird in der \enword{Lookup}-Tabelle keine passende Implementierung gefunden, wird ein Fehler geworfen und die Ausführung abgebrochen. Handelt es sich jedoch um ein \enword{KeywordDecl}-Objekt wird das \enword{Keyword} ausgeführt.  

\SuperPar
Dabei muss die \enword{Stack}-Maschine überprüfen, ob es sich um ein \enword{Scripted-Compound-Keyword} handelt. Bei einem \enword{Scripted-Compound-Keyword} muss eine andere Logik ausgeführt werden, da es sowohl eine Code-Implementierung als auch eine \enword{Keyword}-Liste vorhanden ist. Bei allen anderen \enword{Keyword}-Metatypen wird die Methode \enword{executeKeywordDecl} ausgeführt. Diese Methode führt bei einem \enword{Scripted-Keyword} das spezifizierten Codestück aus. Bei einem \enword{Compound-Keyword} wird die \enword{Keyword}-Liste in den Gültigkeitsbereich geladen.

\SuperPar
Wurden alle Gültigkeitsbereich am \enword{Stack} erfolgreich abgearbeitet wird am Ende noch das \enword{Reporter-Interface} aufgerufen. Danach wird die Ausführung der \enword{Stack}-Maschine beendet.

%%------------------------------------------------------------------------------------------------------
\clearpage

\section{Auswertung von Ausdrücken}
\label{cha:Eval}

Dieser Abschnitt befasst sich mit den Grammatik-Regeln und der Ausführung von Ausdrücken. Die Rayden-Sprache unterstützt in einigen Bereichen der Sprache Ausdrücke. Ein Ausdruck kann in der Grammatik mit der Regel \enword{Expr} aufgerufen werden. Die Abbidlung \ref{fig:exprGrammar} zeigt einen Überblick über die Grammatik-Regeln von Ausdrücke. 

\begin{figure}
\centering
\includegraphics[width=0.9\textwidth]{grammar-expr.png}
\caption{Grammatik-Regeln für Ausdrücke}
\label{fig:exprGrammar}
\end{figure}

\SuperPar
Die Regeln für den Ausdruck sind klassisch aufgebaut. Die Operationen sind nach der Ausführungsreihenfolge in den Regeln eingearbeitet. Die am stärksten bindenden Operationen befinden sich in der Nähe der Blätter des Ausdrucksbaum. Die schwach bindenden Operationen befinden sich in der Nähe des Wurzelknotens. Die Blätter repräsentieren die Werte in einem Ausdruck, welche in der Regel \enword{Fact} definiert werden. Die Werte können entweder Konstanten oder Variablen sein und haben eine definierten Datentypen. Die Regel \enword{Fact} hat jedoch keinen spezielle Behandlung für \enword{Enumerations}. Der Grund dafür ist, dass \enword{Enumerations} intern als \enword{Strings} verarbeitet werden. Die Validierung der\enword{Enumerations} wird nur beim Initialisieren von Gültigkeitsbereichen durchgeführt.

\SuperPar
Für die Ausführung von Ausdrücken ist im Rayden-System die Klasse \enword{RaydenExpressionEvaluator} zuständig. Der Codeausschnitt \ref{prog:evaluator} zeigt eine Überblick über die Klasse \enword{RaydenExpressionEvaluator}. Die Klasse wird mit einem Gültigkeitsbereich initialisiert. Der Gültigkeitsbereich wird benötigt um Variablen bei der Abarbeitung auswerten zu können. 

\SuperPar
Die Auswertung eines Ausdrucks wird mit der Methode \enword{eval(Expr expression, String resultType)} gestartet. Als Parameter für die Methode wird ein \enword{Expr}-Objekt und eine Zeichenkette übergeben. Das \enword{Expr}-Objekt ist das Wurzelobjekt im \enword{ECore}-Modell für eine Ausdruck. Mit dem zweiten Parameter kann man die Auswertung des Ausdrucks typisieren. Wurde ein Typ definiert, wird am Ende der Auswertung noch überprüft, ob das Ergebnis vom selben Typ ist. Stimmt der Wert nicht überein, wird eine Fehler geworfen. Es gibt auch noch eine Spezialfall bei der Typisierung. Wird ein Ausdruck mit dem Typ \enword{variable} parametrisiert, werden keine Variablen im Ausdruck ausgewertet. Diese Eigenschaft wird benötigt, um Variablennamen an ein \enword{Keyword} übergeben zu können.

\SuperPar
Der Codeausschnitt \ref{prog:evaluator} enthählt am Ende die Implementierung der \enword{eval}-Methode für das Objekt \enword{Fact}. Diese Methode zeigt, wie die Werte aus dem \enword{ECore}-Modell nach \enword{Java} konvertiert werden. Die Methode zeigt auch, wie Variablen mithilfe des Gültigkeitsbereichs ausgewertet werden können.

\begin{program}
\lstinputlisting{samplecode/RaydenExpressionEvaluator.java}
\caption{Codeauszug aus dem \enword{RaydenExpressionEvaluator}}
\label{prog:evaluator}
\end{program}

%%------------------------------------------------------------------------------------------------------
\clearpage
\section{Validierung eines Rayden-Tests}
\label{cha:validateKeyword}

Um die Entwicklung und Wartung von Rayden-Tests zu unterstützen wurden neben einer syntaktischen Validierung von Tests auch zusätzliche Validierungen hinzugefügt. Für die Umsetzung der Validierungen wurde eine Schnittstelle des \enword{xText-Framworks} verwendet. Nachdem eine Datei erfolgreich durch den \enword{xText-Compiler} geladen werden konnte, können zusätzliche Validierungen vorgenommen werden. Der Vorteil bei diesem Vorgehen ist, dass in dieser Phase bereits das gesamte \enword{ECore}-Modell geladen worden ist. Die Validierungen können somit für Überprüfungen auf das gesamte Modell zugreifen. In dieser Phase ist auch schon sichergestellt, dass es keinen syntaktischen Fehler mehr gibt, da diese Fehler bereits im \enword{Compiler} auftreten.

\begin{program}
\lstinputlisting{samplecode/Validator.java}
\caption{Codeauszug aus dem \enword{RaydenDSLJavaValidator}}
\label{prog:validator}
\end{program}

\SuperPar
Um Validierungen implementieren zu können wird von \enword{xText} ein Klasse generiert, welche mit \enword{JavaValidator} endet. Im Fall von Rayden heißt die Klasse \enword{RaydenDSLJavaValidator}. In dieser Klasse können nun sprachspezfische Validierungen hinzugefügt werden. Jede Methode in dieser Klasse, welche mit einer \enword{@Check} Annotation gekennzeichnet ist, wird als Validierung ausgeführt. 

\SuperPar
Das Codebeispiel \ref{prog:validator} zeige eine Validierung für die Verwendung von \enword{Keywords}. Diese Validierung wird für alle \enword{KeywordCall} Modellelemente aufgerufen. Ein \enword{KeywordCall} stellt einen Aufruf von einem \enword{Keyword} dar. Die Validierung überprüft, ob für jeden Aufruf von einem \enword{Keyword} auch eine Implementierung vorhanden ist. Das Traversieren des Modell und suchen alle Modellelementen entfällt, da diese Aufgabe vom \enword{xText-Framework} durchgeführt wird.

\SuperPar
Im ersten Schirtt überprüft die Validierung aus dem Codebeispiel \ref{prog:validator} ob es sich um ein \enword{Inline-Keyword} handelt. Falls das \enword{KeywordCall}-Modellelement ein \enword{Inline-Keyword} repräsentiert, kann die Validierung beendet werden, da ein \enword{Inline-Keyword} direkt in einem \enword{KeywordCall}-Element implementiert ist. Falls es sich nicht um ein \enword{Inline-Keyword} handelt, werden im nächsten Schritt mithilfe der \enword{Lookup}-Tabellen gesucht, ob eine Implementierung für das \enword{Keyword} vorhanden ist. Wurde keine Implementierung gefunden, wird eine Warnung ausgegeben. Das Fehlen einer Implementierung liefert nur eine Warnung. Würde diese Validierung einen Fehler liefern, würde der \enword{Compiler} mit diesem Fehler abbrechen und es können keine Tests ausgeführt werden, obwohl diese nicht von dem Fehler betroffen wären. Diese Warnung soll vielmehr eine Unterstützung für die Testerinnen und Tester sein um fehlende \enword{Keyword}-Implementierungen zu finden.

%%------------------------------------------------------------------------------------------------------

\section{Integration von Rayden in das \enword{Java-Scripting-API}}
\label{cha:implementJSA}

Das Rayden-System besitzt eine Integration in das \enword{Java-Scripting-API}. Das \enword{Java-Scripting-API} ist eine standardisierte Schnittstelle für das Ausführen von Skriptsprachen in \enword{Java}. Über diese Schnittstellen kann direkt in einem \enword{Java}-Programm ein Skript in einer beliebigen Sprache ausführen. Die einzige Einschränkung dabei ist, dass für die Skriptsprache eine \enword{ScriptEngineFactory} registriert worden ist. Das \enword{Java-Scripting-API} ist vergleichbar mit der \enword{Dynamic Language Runtime} \cite{DLR} in \enword{Microsoft .Net}. Mit der \enword{Dynamic Language Runtime} ist es zum Beispiel in \enword{C\#} möglich, ein Python-Skript \cite{Python} auszuführen.

\begin{figure}
\centering
\includegraphics[width=0.7\textwidth]{ScriptEngineFactory.png}
\caption{ScriptEngineFactory UML-Klassendiagramm}
\label{fig:scriptEngineFactoryUml}
\end{figure}

\begin{program}
\lstinputlisting{samplecode/ScriptEngine.java}
\caption{Codeauszug aus der \enword{RaydenScriptEngine}}
\label{prog:scriptEngine}
\end{program}

\SuperPar
Für die Integration einer neuen Skriptsprache in das \enword{Java-Scripting-API} muss man die Schnittstellen \enword{javax.script.ScriptEngineFactory} und \enword{javax.script.ScriptEngine} implementieren. Diese beiden Schnittstellen bilden das Bindeglied zwischen der \enword{Java}- und der Skriptsprachen-Welt. Die \enword{ScriptEngineFactory}-Schnittstelle liefert Metadaten zu einer Skriptsprache wie den Namen oder die Versionsnummer. Einen Überblick über die Schnittstelle gibt die Abbildung \ref{fig:scriptEngineFactoryUml}. Die wichtigste Methode der Schnittstelle ist aber \enword{getScriptEngine()}. Diese Methode liefert ein \enword{Script-Engine}-Objekt.

\SuperPar
Über ein \enword{Script-Engine}-Objekt können Skripts ausgeführt werden. Für die Ausführung stehen unterschiedliche Ausprägungen der Methode \enword{eval()} zur Verfügung. Der Skriptcode kann entweder als Zeichenkette oder als \enword{Reader} übergeben werden. Mit einem \enword{Reader} kann man ein Skript direkt aus einer Datei einlesen. Der Codeauszug \ref{prog:scriptEngine} zeigt die Hauptimplementierung der \enword{eval()} Methode aus der \enword{RaydenScriptEngine}-Klasse. Zu Beginn der Methode wird die Rayden-\enword{Runtime} instanziiert und initialisiert. Die \enword{Runtime} wird benötigt, um einen Rayden-Test ausführen zu können. Im näcshten Schritt wird überprüft, ob ein spezieller \enword{Reporter} verwendet werden soll. Standardmäßig wird die \enword{RaydenXMLReporter}-Implementierung verwendet, welche die gesamte Ausgaben einer Test-Ausführung in eine XML-Datei protokolliert. 

\SuperPar
Damit man in einem Rayden-Test eine Bibliothek verwenden kann, ist es für die \enword{Runtime} entscheiden, dass spezifiziert ist, wo die Bibliotheken gefunden werden. Dafür wird ein Arbeitsbereich (\enword{Working Folder}) definiert, in welchem Bibliotheken und andere externe Ressourcen gesucht werden. Der Arbeitsbereich ist standardmäßig das Ausführungsverzeichnis der Java-Anwendung. Der Wert kann aber über einen Kontextparameter verändert werden. Kontextparameter werden verwendet um Parameter an die \enword{Script Engine} übergeben zu können. 

\begin{program}
\lstinputlisting{samplecode/RuntimeLoadFile.java}
\caption{Laden von Rayden-Dateien}
\label{prog:loadFile}
\end{program}

\SuperPar
Nachdem alle Einstellungen für die Rayden-\enword{Runtime} vorgenommen worden sind, wird das Skript mit allen Abhängigkeiten geladen. Dazu wird das Skript mit der Methode \enword{loadRaydenFile()} geladen. Die Implementierung der Methode zeigt der Codeauszug \ref{prog:loadFile}. Wie der Codeauszug zeigt, gibt es zwei Methoden für das Laden von Rayden-Dateien. Die erste Methode \enword{loadRaydenFile()} ist für das Laden der primären Rayden-Datei zuständig. Mit der zweiten Methode \enword{loadLibraryFile()} werden Bibliotheken geladen. Der Hauptgrund für die zwei unterschiedlichen Methoden ist der, dass es zwei \enword{Lookup}-Tabellen für \enword{Keywords} vorhanden sind. Es werden alle \enword{Keywords} aus der primären Rayden-Datei in eine spezielle \enword{Lookup}-Tabelle geladen, dass nur \enword{Keywords} aus dieser Datei ausgeführt werden können.

\SuperPar
Zum Laden der Rayden-Datei wird der generierte xText-\enword{Parser} verwendet. Im nächsten Schritt wird das Ergebnis des \enword{Parser} überprüft, ob ein Syntaxfehler aufgetreten ist. Bei einem Fehler wird die Ausführung sofort beendet. Konnte die Datei ohne Fehler geladen werden, liefert der \enword{Parser} eine Instanz des \enword{ECore}-Modells. Es wird das Modell durchlaufen und alle \enword{Keywords} die gefunden werden in die \enword{Lookup}-Tabelle gespeichert. Im letzten Schritt werden noch alle Bibliotheken geladen. Das Laden einer Bibliothek funktioniert identisch wie das laden der primären Rayden-Datei, nur wird in diesem Fall die \enword{Keywords} in eine andere \enword{Lookup}-Tabelle gespeichert. 

\SuperPar
Nachdem das Skript und alle externe Ressourcen erfolgreich geladen worden sind, können die Rayden-Tests ausgeführt werden. Dazu stellt die Rayden-\enword{Runtime} die Methode \enword{executeAllTestSuites()} zur Verfügung. Die Methode sucht in der primären \enword{Lookup}-Tabelle nach \enword{Keywords} mit einem Testtypen. Die Rayden-Sprache unterstützt folgende Testtypen:

\begin{itemize}
\item Test-Suite (\enword{TestSuite}),
\item Testfall (\enword{TestCase}),
\item Komponententest (\enword{UnitTest}),
\item Integrationstest (\enword{IntegrationTest}),
\item Schnittstellentest (\enword{APITest}),
\item Automatisierter Abnahme-Test (\enword{AUTest}) und
\item Manueller Abnahme-Test (\enword{MAUTest}).
\end{itemize}

\SuperPar
Alle gefunden Tests werden im nächsten Schritt sequenziell ausgeführt. Als Resultat der Skriptausführung wird das kumuliere Ergebnis der ausgeführten Tests geliefert. Das Ergebnis kann dann entweder in der Java-Anwendung oder nachträglich über die XML-Datei ausgewertet werden.

\SuperPar
In diesem Kapitel wurden einige essentielle Komponenten des Rayden-Systems gezeigt und wie die Komponenten umgesetzt worden sind. Im nächsten Kapitel \ref{cha:Testen} wird gezeigt, wie man Tests mit dem Rayden-System schreiben kann. Dazu werden unterschiedliche Test-Methoden verwendet um die Stärken von Rayden zu zeigen.
